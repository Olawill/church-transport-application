// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client"
  output   = "../src/generated/prisma"
  engineType = "client"
}

datasource db {
  provider = "postgresql"
  // url      = env("DATABASE_URL")
}

enum UserRole {
  // Platform Users
  PLATFORM_ADMIN
  PLATFORM_SUPERUSER
  PLATFORM_USER

  // Tenants
  ADMIN
  TRANSPORTATION_TEAM
  USER
  OWNER
}

enum UserStatus {
  PENDING
  APPROVED
  REJECTED
  BANNED
}

enum AppealStatus {
  PENDING
  UNDER_REVIEW
  APPROVED
  REJECTED
}


enum ServiceType {
  REGULAR
  SPECIAL
}

enum ServiceCategory {
  ONETIME_ONEDAY
  ONETIME_MULTIDAY
  FREQUENT_MULTIDAY
  RECURRING
}

enum Frequency {
  DAILY
  WEEKLY
  MONTHLY
  EVERY_2_MONTHS
  QUARTERLY
  EVERY_4_MONTHS
  EVERY_6_MONTHS
  YEARLY
  NONE
}

enum Ordinal {
  NEXT
  FIRST
  SECOND
  THIRD
  FOURTH
  LAST
}

enum BranchType {
  HEADQUARTER
  BRANCH
}

enum RequestStatus {
  PENDING
  ACCEPTED
  COMPLETED
  CANCELLED
}

enum SubscriptionStatus {
  ACTIVE
  CANCELLED
  EXPIRED
  FREE_FOR_LIFE
}

enum OTPType {
  EMAIL_VERIFICATION
  PHONE_VERIFICATION
  LOGIN_VERIFICATION
  PASSWORD_RESET
}

enum OTPChoice {
  TOTP
  OTP
}

model Account {
  id                    String     @id @default(cuid())
  accountId             String
  providerId            String

  userId                String
  user                  User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  accessToken           String?
  refreshToken          String?
  idToken               String?
  expiresAt             DateTime?
  password              String?
  accessTokenExpiresAt  DateTime?
  refreshTokenExpiresAt DateTime?
  scope                 String?

  createdAt             DateTime          @default(now())
  updatedAt             DateTime          @updatedAt

  @@map("account")
}

model Session {
  id                  String      @id @default(cuid())
  expiresAt           DateTime
  ipAddress           String?
  userAgent           String?

  impersonatedBy      String?

  userId              String
  user                User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  token               String
  activeOrganizationId String?
  activeTeamId        String?

  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  @@unique([token])
  @@map("session")
}

model User {
  id                  String       @id @default(cuid())
  name                String
  username            String?      @unique

  email               String       @unique
  emailVerified       Boolean      @default(false)
  
  phoneNumber         String?
  whatsappNumber      String?
  phoneNumberVerified Boolean      @default(false)
  
  
  image               String?
  role                UserRole     @default(USER)
  status              UserStatus   @default(PENDING)
  isActive            Boolean      @default(true)
  
  maxDistance         Int          @default(10) // For transportation team members

  banned              Boolean       @default(false)
  bannedAt            DateTime?
  bannedBy            String?
  banReason           String?
  banExpires          DateTime?

  isAdminCreated      Boolean       @default(false)
  firstLoginAt        DateTime?
  
  createdAt           DateTime      @default(now())
  updatedAt           DateTime      @updatedAt

  emailNotifications  Boolean       @default(false)
  whatsAppNotifications Boolean     @default(false)
  smsNotifications    Boolean       @default(false)

  appeal              Appeal?
  accounts            Account[]
  sessions            Session[]
  
  addresses           Address[]
  pickupRequests      PickupRequest[] @relation("UserRequests")
  acceptedRequests    PickupRequest[] @relation("DriverRequests")
  cancelledRequests   DriverRequestCancel[] @relation("DriverRequestsCancel")
  subscription        Subscription?

  twoFactor           TwoFactor?
  twoFactorEnabled    Boolean       @default(false)
  twoFactorMethod     OTPChoice?

  members             Member[]
  invitations         Invitation[]

  teamMembers         TeamMember[]


  @@index([email])
  @@map("users")
}

model Appeal {
  id              String   @id @default(cuid())
  email           String
  reason          String   @db.Text
  additionalInfo  String?  @db.Text
  status          AppealStatus @default(PENDING)
  
  // Optional: link to user if they exist
  userId          String?  @unique
  user            User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Admin review fields
  reviewedBy      String?
  reviewedAt      DateTime?
  reviewNotes     String?  @db.Text
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt
  
  @@index([email])
  @@index([status])
  @@index([createdAt])
}

model TwoFactor {
  id                  String       @id @default(cuid())

  userId              String
  user                User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  secret              String?
  backupCodes         String?

  @@unique([userId])
  @@map("twoFactor")
}

model Verification {
  id                  String           @id @default(cuid())

  identifier          String
  value               String
  expiresAt           DateTime

  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  @@unique([identifier, value])
  @@map("verification")
}

model Address {
  id                  String            @id @default(cuid())
  userId              String
  name                String            // e.g., "Home", "Work", "Other"
  street              String
  city                String
  province            String
  postalCode          String
  country             String            @default("Canada")
  latitude            Float?
  longitude           Float?
  isDefault           Boolean           @default(false)
  isActive            Boolean           @default(true)
  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  user                User              @relation(fields: [userId], references: [id], onDelete: Cascade)
  pickupRequests      PickupRequest[]

  @@unique([userId, name])              // Prevent duplicate address names per user
  @@index([userId, isDefault])
  @@map("addresses")
}

model ServiceDay {
  id                  String            @id @default(cuid())
  name                String

  time                String            // Format: "HH:MM" (24-hour)
  serviceType         ServiceType       @default(REGULAR)
  isActive            Boolean           @default(true)

  startDate           DateTime?         // For one-time or multi-day services
  endDate             DateTime?         // For multi-day services
  serviceCategory     ServiceCategory   @default(RECURRING)
  ordinal             Ordinal           @default(NEXT)
  frequency           Frequency         @default(WEEKLY)
  cycle               Int?
  // cycleType           CycleType?

  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  pickupRequests      PickupRequest[]
  weekdays            ServiceDayWeekday[]

  @@map("service_days")
}

model ServiceDayWeekday {
  id           String      @id @default(cuid())
  serviceDayId String
  dayOfWeek    Int         // 0 = Sunday, 1 = Monday, etc.

  serviceDay   ServiceDay  @relation(fields: [serviceDayId], references: [id], onDelete: Cascade)
  rides        PickupRequest[]

  @@unique([serviceDayId, dayOfWeek])
}

model PickupRequest {
  id                  String            @id @default(cuid())

  userId              String
  driverId            String?

  serviceDayId        String
  serviceWeekdayId    String

  addressId           String
  requestDate         DateTime          // The date of the service
  status              RequestStatus     @default(PENDING)
  notes               String?
  isPickUp            Boolean           @default(true)
  isDropOff           Boolean           @default(false)
  isGroupRide         Boolean           @default(false)
  numberOfGroup       Int?
  distance            Float?            // Distance from driver to pickup location
  seriesId            String?           // FK to PickupSeries

  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  user                User              @relation("UserRequests", fields: [userId], references: [id])
  driver              User?             @relation("DriverRequests", fields: [driverId], references: [id])
  serviceDay          ServiceDay        @relation(fields: [serviceDayId], references: [id])
  address             Address           @relation(fields: [addressId], references: [id])

  cancelledRequests   DriverRequestCancel[]
  serviceWeekday      ServiceDayWeekday @relation(fields: [serviceWeekdayId], references: [id])
  series              PickupSeries?     @relation(fields: [seriesId], references: [id])

  @@index([userId, serviceDayId, requestDate]) // For duplicate checking
  @@index([seriesId, requestDate]) // For series queries
  @@index([status, requestDate]) // For filtering
  @@index([serviceDayId, serviceWeekdayId])
  @@map("pickup_requests")
}

model PickupSeries {
  id              String            @id @default(cuid())
  createdAt       DateTime          @default(now())
  pickupRequests  PickupRequest[]

  @@map("pickup_series")
}

model DriverRequestCancel {
  id                  String            @id @default(cuid())
  driverId            String
  requestId           String
  note                String
  createdAt           DateTime          @default(now())

  driver              User              @relation("DriverRequestsCancel", fields: [driverId], references: [id])
  request             PickupRequest     @relation(fields: [requestId], references: [id])

  @@map("driver_requests_cancel")
}

model Organization {
  id                     String            @id @default(cuid())
  churchName             String            @unique @map("name")
  churchAcronym          String?           @unique       
  churchLogo             String?           @map("logo")
  slug                   String
  metadata               String?

  createdAt              DateTime          @default(now())
  updatedAt              DateTime          @updatedAt

  members                Member[]
  invitations            Invitation[]

  organizationBranches   OrganizationBranch[]

  @@unique([slug])
  @@map("organization")
}

model Member {
  id                     String            @id @default(cuid())
  organizationId         String
  organization           Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)
  userId                 String
  user                   User      @relation(fields: [userId], references: [id], onDelete: Cascade)
  role           UserRole

  createdAt              DateTime          @default(now())

  @@map("member")
}

model Invitation {
  id                     String            @id @default(cuid())
  organizationId         String
  organization           Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  email                  String
  role                   UserRole?
  status                 String
  expiresAt              DateTime

  inviterId              String
  user                   User      @relation(fields: [inviterId], references: [id], onDelete: Cascade)

  teamId                 String?

  @@map("invitation")
}

model OrganizationBranch {
  id                  String            @id @default(cuid())
  branchName          String            @map("name")
  branchCategory      BranchType        @default(BRANCH)

  street              String
  city                String
  province            String
  postalCode          String
  country             String
  churchPhone         String
  requestCutOffInHrs  String
  defaultMaxDistance  String

  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  teammembers         TeamMember[]

  organizationId      String
  organization        Organization      @relation(fields: [organizationId], references: [id], onDelete: Cascade)

  @@map("team")
}

model TeamMember {
  id                  String            @id @default(cuid())

  createdAt           DateTime          @default(now())
  updatedAt           DateTime          @updatedAt

  teamId              String
  team                OrganizationBranch      @relation(fields: [teamId], references: [id], onDelete: Cascade)

  userId              String
  user                User      @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("teamMember")
}


model Subscription {
  id                  String             @id @default(cuid())
  userId              String             @unique
  status              SubscriptionStatus @default(ACTIVE)
  isFreeForLife       Boolean            @default(false)
  currentPeriodStart  DateTime?
  currentPeriodEnd    DateTime?
  cancelledAt         DateTime?
  trialEnd            DateTime?
  metadata            String?            // JSON for additional subscription info
  createdAt           DateTime           @default(now())
  updatedAt           DateTime           @updatedAt

  user                User               @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("subscriptions")
}

model Analytics {
  id                  String              @id @default(cuid())
  eventType           String              // e.g., "pickup_request", "user_registration", "driver_acceptance"
  userId              String?
  metadata            String?             // JSON data for additional context
  value               Float?              // Numerical value if applicable
  date                DateTime            @default(now())
  createdAt           DateTime            @default(now())

  @@index([eventType, date])
  @@index([userId, eventType])
  @@map("analytics")
}

model Notification {
  id                  String              @id @default(cuid())
  userId              String
  type                String              // "whatsapp", "email", "push"
  title               String
  message             String
  status              String              @default("pending") // "pending", "sent", "failed"
  scheduledFor        DateTime?
  sentAt              DateTime?
  metadata            String?             // JSON for additional notification data
  createdAt           DateTime            @default(now())

  @@index([userId, status])
  @@index([scheduledFor])
  @@map("notifications")
}